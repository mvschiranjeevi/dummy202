
/*
 * ! @chakra-ui/vue v0.13.1 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('./index-aaaef82b.js');
require('./chakra-ui-styled-system.esm-0de8acbf.js');
require('./clickoutside.directive-e742e45f.js');
require('@emotion/css');
require('vue');
require('./color-mode-observer-121d1df0.js');
var CBox = require('./CBox.js');
require('./CPseudoBox.js');
require('./CPortal.js');
require('./CNoSsr.js');
var CVisuallyHidden = require('./CVisuallyHidden.js');
var CFragment = require('./CFragment.js');
var CPopper = require('./CPopper.js');

/**
 * Hey! Welcome to @chakra-ui/vue Tooltip
 *
 * A Tooltip is a popup that displays information related
 * to an element when the element receives keyboard focus
 * or the mouse hovers over it
 *
 * ðŸš¨NOTE: The WAI-ARIA design pattern for Tooltips is work in
 * progress; it does not yet have task force consensus.
 * Progress and discussions are captured in
 * [issue 128](https://github.com/w3c/aria-practices/issues/128).
 *
 * @see Docs     https://vue.chakra-ui.com/tooltip
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CTooltip/CTooltip.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CTooltip/accessibility.md
 */
var tooltipProps = {
  label: String,
  _ariaLabel: String,
  showDelay: {
    type: Number,
    default: 0
  },
  hideDelay: {
    type: Number,
    default: 0
  },
  placement: {
    type: String,
    default: 'top'
  },
  hasArrow: Boolean,
  closeOnClick: Boolean,
  defaultIsOpen: Boolean,
  shouldWrapChildren: Boolean,
  controlledIsOpen: Boolean,
  isControlled: Boolean,
  onOpen: Function,
  onClose: Function
};
/**
 * CTooltip component
 *
 * A tooltip is a brief, informative message that appears when a
 * user interacts with an element.
 *
 * The `CTooltip` achieves this by cloning it's children VNodes
 * and then attaches hover and focus events to it in order to display
 * and hide the tooltip conveniently as per WAI-ARIA specs
 *
 * @extends CPopper
 * @see Docs https://vue.chakra-ui.com/tooltip
 */

var CTooltip = {
  name: 'CTooltip',
  inject: ['$chakraColorMode'],
  inheritAttrs: false,
  data: function data() {
    return {
      isOpen: this.isControlled ? this.controlledIsOpen : this.defaultIsOpen || false,
      enterTimeout: null,
      exitTimeout: null,
      tooltipAnchor: undefined,
      noop: 0
    };
  },
  computed: {
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    tooltipId: function tooltipId() {
      return "tooltip-" + utils.useId(4);
    }
  },
  methods: {
    open: function open() {
      this.isOpen = true;
    },
    close: function close() {
      this.isOpen = false;
    },
    openWithDelay: function openWithDelay() {
      this.enterTimeout = setTimeout(this.open, this.showDelay);
    },
    closeWithDelay: function closeWithDelay() {
      this.exitTimeout = setTimeout(this.close, this.hideDelay);
    },
    handleOpen: function handleOpen() {
      if (!this.isControlled) {
        this.openWithDelay();
      }

      this.open && this.open();
      this.$emit('open');
    },
    handleClose: function handleClose() {
      if (!this.isControlled) {
        this.closeWithDelay();
      }

      this.close && this.close();
      this.$emit('close');
    },
    handleClick: function handleClick() {
      this.closeOnClick && this.closeOnClick();
      this.$emit('click');
    },
    handleKeydown: function handleKeydown(event) {
      var key = event.key;

      if (key === 'Escape') {
        this.handleClose();
      }
    }
  },
  props: tooltipProps,
  mounted: function mounted() {
    var this$1 = this; // When component is mounted we force re-render because component
    // children may not yet be rendered so event listeners may not be
    // Attached immediately.

    this.$nextTick(function () {
      this$1.noop++;
      this$1.tooltipAnchor = document.querySelector("[x-tooltip-anchor=" + this$1.tooltipId + "]");
    });
  },
  render: function render(h) {
    var this$1 = this;
    var clone; // Styles for tooltip

    var _bg = this.colorMode === 'dark' ? 'gray.300' : 'gray.700';

    var _color = this.colorMode === 'dark' ? 'gray.900' : 'whiteAlpha.900'; // ARIA label for tooltip


    var hasAriaLabel = this._ariaLabel !== undefined; // Child nodes parsing

    var children = this.$slots.default;

    if (children.length > 1) {
      return console.error('[ChakraUI]: The CTooltip component only expects one child.');
    }

    if (children[0].text || this.shouldWrapChildren) {
      clone = clone = h(CBox.default, {
        props: {
          as: 'span'
        },
        attrs: Object.assign({}, {
          tabindex: 0,
          'x-tooltip-anchor': "" + this.tooltipId
        }, this.isOpen && {
          'aria-describedby': this.tooltipId
        }),
        on: {
          mouseenter: this.handleOpen,
          mouseleave: this.handleClose,
          click: this.handleClick,
          focus: this.handleOpen,
          blur: this.handleClose,
          keydown: this.handleKeydown
        },
        ref: 'tooltipRef'
      }, children[0].text);
    } else {
      var cloned = utils.cloneVNode(children[0], h);

      if (cloned.componentOptions) {
        clone = h(cloned.componentOptions.Ctor, Object.assign({}, cloned.data, cloned.componentOptions.listeners || {}, {
          props: Object.assign({}, cloned.data.props || {}, cloned.componentOptions.propsData),
          attrs: Object.assign({}, cloned.data.attrs, this.isOpen && {
            'aria-describedby': this.tooltipId
          }, {
            'x-tooltip-anchor': "" + this.tooltipId
          }),
          on: cloned.componentOptions.listeners,
          nativeOn: {
            mouseenter: this.handleOpen,
            mouseleave: this.handleClose,
            click: utils.wrapEvent(this.handleClick, function (e) {
              return this$1.$emit('click', e);
            }),
            focus: this.handleOpen,
            blur: this.handleClose,
            keydown: this.handleKeydown
          }
        }), cloned.componentOptions.children);
      }
    }

    return h(CFragment.default, [clone, h(CPopper.CPopper, {
      props: Object.assign({}, {
        usePortal: true,
        anchorEl: this.tooltipAnchor,
        hasArrow: true,
        isOpen: this.isOpen,
        placement: this.placement,
        modifiers: [{
          name: 'offset',
          options: {
            offset: [0, 8]
          }
        }],
        arrowSize: '10px'
      }, utils.pickProperty(this.$props)),
      attrs: Object.assign({}, {
        px: '8px',
        py: '2px',
        bg: _bg,
        borderRadius: 'sm',
        fontWeight: 'medium',
        pointerEvents: 'none',
        color: _color,
        fontSize: 'sm',
        shadow: 'md',
        maxW: '320px'
      }, this.$attrs, {
        id: hasAriaLabel ? undefined : this.tooltipId,
        role: hasAriaLabel ? undefined : 'tooltip',
        'data-noop': this.noop,
        'data-chakra-component': 'CTooltip'
      })
    }, [this.label, hasAriaLabel && h(CVisuallyHidden.default, {
      attrs: {
        role: 'tooltip',
        id: this.tooltipId
      }
    }, this._ariaLabel), this.hasArrow && h(CPopper.CPopperArrow)])]);
  }
};

exports.default = CTooltip;
