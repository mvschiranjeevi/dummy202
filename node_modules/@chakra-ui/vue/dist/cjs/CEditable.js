
/*
 * ! @chakra-ui/vue v0.13.1 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('./index-aaaef82b.js');
require('./chakra-ui-styled-system.esm-0de8acbf.js');
require('@emotion/css');
require('vue');
require('./color-mode-observer-121d1df0.js');

/**
 * Hey! Welcome to @chakra-ui/vue Editable
 *
 * EditableText is used for inline renaming of some text.
 *
 * It appears as normal UI text but transforms into a text
 * input field when the user clicks or focuses on it.
 *
 * The text input inherits all font styling from its parent,
 * to make the edit and read view transition seamless.
 *
 * @see Docs     https://vue.chakra-ui.com/editable
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CEditable/CEditable.js
 */
var sharedEditableProps = {
  fontSize: 'inherit',
  fontWeight: 'inherit',
  textAlign: 'inherit',
  bg: 'transparent',
  transition: 'all 0.2s',
  borderRadius: 'md',
  px: '3px',
  mx: '-3px'
};
/**
 * CEditable component
 *
 * The wrapper for `CEditable` components. It provides context and state for the Editable components.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/editable
 */

var CEditable = {
  name: 'CEditable',
  mixins: [utils.createStyledAttrsMixin('CEditable')],
  props: {
    value: String,
    defaultValue: String,
    isDisabled: Boolean,
    startWithEditView: Boolean,
    selectAllOnFocus: {
      type: Boolean,
      default: true
    },
    submitOnBlur: {
      type: Boolean,
      default: true
    },
    isPreviewFocusable: {
      type: Boolean,
      default: true
    },
    placeholder: {
      type: String,
      default: 'Click to edit...'
    }
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $EditableContext: function $EditableContext() {
        return this$1.EditableContext;
      }
    };
  },
  data: function data() {
    return {
      isEditing: this.startWithEditView && !this.isDisabled,
      innerValue: this.defaultValue || '',
      previousValue: this._value,
      inputNode: null
    };
  },
  computed: {
    isControlled: function isControlled() {
      return utils.isDef(this.value);
    },
    _value: function _value() {
      return this.isControlled ? this.value : this.innerValue;
    },
    editableId: function editableId() {
      return "editable-" + utils.useId();
    },
    EditableContext: function EditableContext() {
      return {
        editableId: this.editableId,
        isEditing: this.isEditing,
        isDisabled: this.isDisabled,
        placeholder: this.placeholder,
        onRequestEdit: this.onRequestEdit,
        submitOnBlur: this.submitOnBlur,
        isPreviewFocusable: this.isPreviewFocusable,
        value: this._value,
        onKeyDown: this.handleKeyDown,
        onChange: this.handleChange,
        onSubmit: this.handleSubmit,
        onCancel: this.handleCancel,
        onFocus: this.handleFocus
      };
    }
  },
  created: function created() {
    // Initialize previousValue to computed _value
    this.previousValue = this._value;
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('isEditing', function (newVal) {
      if (newVal) {
        this$1.$emit('edit');
      }
    });
    this.$watch(function (vm) {
      return [vm.isEditing, vm.selectAllOnFocus];
    }, function () {
      this$1.$nextTick(function () {
        this$1.inputNode = utils.getElement("#" + this$1.editableId, this$1.$el);

        if (this$1.isEditing && this$1.inputNode) {
          this$1.inputNode.focus();
          this$1.selectAllOnFocus && this$1.inputNode.select();
        }
      });
    });
  },
  methods: {
    /**
     * Handle cancel event
     */
    handleCancel: function handleCancel() {
      this.isEditing = false;
      this.innerValue = this.previousValue;

      if (this.innerValue !== this.previousValue) {
        this.$emit('change', this.previousValue);
      }

      this.$emit('cancel', this.previousValue);
    },

    /**
     * Handle submit event
     */
    handleSubmit: function handleSubmit() {
      this.isEditing = false;
      this.previousValue = this.innerValue;
      this.$emit('submit', this.innerValue);
    },

    /**
     * Handle change event
     */
    handleChange: function handleChange(event) {
      var ref = event.target;
      var value = ref.value;

      if (!this.isControlled) {
        this.innerValue = value;
      }

      this.$emit('change', this.innerValue);
    },

    /**
     * Handle keydown event
     */
    handleKeyDown: function handleKeyDown(event) {
      var key = event.key;

      if (key === 'Escape') {
        this.handleCancel();
        return;
      }

      if (key === 'Enter') {
        this.handleSubmit();
      }
    },

    /**
     * Handle focus event
     */
    handleFocus: function handleFocus(event) {
      if (this.selectAllOnFocus) {
        this.inputNode.select();
      }
    },

    /**
     * Handle request editing
     */
    onRequestEdit: function onRequestEdit() {
      if (!this.isDisabled) {
        this.isEditing = true;
      }
    }
  },
  render: function render(h) {
    return h('div', {
      class: this.className,
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, [this.$scopedSlots.default({
      isEditing: this.isEditing,
      onSubmit: this.handleSubmit,
      onCancel: this.handleCancel,
      onRequestEdit: this.onRequestEdit
    })]);
  }
};
/**
 * CEditablePreview component
 *
 * The read-only view of the component.
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/editable
 */

var CEditablePreview = {
  name: 'CEditablePreview',
  mixins: [utils.createStyledAttrsMixin('CEditablePreview')],
  inject: ['$EditableContext'],
  computed: {
    context: function context() {
      return this.$EditableContext();
    },
    hasValue: function hasValue() {
      return utils.isDef(this.context.value) && this.context.value !== '';
    },
    componentStyles: function componentStyles() {
      return Object.assign({}, sharedEditableProps, {
        cursor: 'text',
        display: 'inline-block',
        opacity: !this.hasValue ? 0.6 : undefined
      });
    },
    tabindex: function tabindex() {
      var ref = this.context;
      var isEditing = ref.isEditing;
      var isDisabled = ref.isDisabled;
      var isPreviewFocusable = ref.isPreviewFocusable;

      if ((!isEditing || !isDisabled) && isPreviewFocusable) {
        return 0;
      }

      return null;
    }
  },
  render: function render(h) {
    var ref = this.context;
    var isEditing = ref.isEditing;
    var isDisabled = ref.isDisabled;
    var onRequestEdit = ref.onRequestEdit;
    var value = ref.value;
    var placeholder = ref.placeholder;

    if (isEditing) {
      return null;
    }

    return h('span', {
      class: [this.className],
      attrs: Object.assign({}, {
        'aria-disabled': isDisabled,
        tabindex: this.tabindex
      }, this.computedAttrs),
      on: Object.assign({}, this.computedListeners, {
        focus: onRequestEdit
      })
    }, this.hasValue ? value : placeholder);
  }
};
/**
 * CEditableInput component
 *
 * The edit view of the component. It shows when you click or focus on the text.
 *
 * @extends CPseudoBox
 * @see Docs https://vue.chakra-ui.com/editable
 */

var CEditableInput = {
  name: 'CEditableInput',
  mixins: [utils.createStyledAttrsMixin('CEditableInput')],
  inject: ['$EditableContext'],
  computed: {
    context: function context() {
      return this.$EditableContext();
    },
    componentStyles: function componentStyles() {
      return Object.assign({}, {
        outline: 'none',
        _focus: {
          shadow: 'outline'
        }
      }, sharedEditableProps, {
        width: 'full',
        _placeholder: {
          opacity: '0.6'
        }
      });
    }
  },
  render: function render(h) {
    var this$1 = this;
    var ref = this.context;
    var isEditing = ref.isEditing;
    var editableId = ref.editableId;
    var onChange = ref.onChange;
    var onKeyDown = ref.onKeyDown;
    var value = ref.value;
    var onSubmit = ref.onSubmit;
    var submitOnBlur = ref.submitOnBlur;
    var placeholder = ref.placeholder;
    var isDisabled = ref.isDisabled;

    if (!isEditing) {
      return null;
    }

    return h('input', {
      class: [this.className],
      on: Object.assign({}, this.computedListeners, {
        blur: function blur(event) {
          submitOnBlur && onSubmit();
          this$1.$emit('blur', event);
        },
        input: onChange,
        keydown: onKeyDown
      }),
      attrs: Object.assign({}, this.computedAttrs, {
        id: editableId,
        disabled: isDisabled,
        'aria-disabled': isDisabled,
        value: value,
        placeholder: placeholder
      })
    }, this.$slots.default);
  }
};

exports.CEditableInput = CEditableInput;
exports.CEditablePreview = CEditablePreview;
exports.default = CEditable;
