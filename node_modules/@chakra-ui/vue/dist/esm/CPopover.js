
/*
 * ! @chakra-ui/vue v0.13.1 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

import { $ as isFunction, J as useId, Z as _typeof, P as isVueComponent, t as getElement, y as cloneVNode, R as createStyledAttrsMixin } from './index-2216d089.js';
import './chakra-ui-styled-system.esm-a8a2e91f.js';
import './internal-icons-3bdf43cd.js';
import './clickoutside.directive-c181c193.js';
import '@emotion/css';
import 'vue';
import './color-mode-observer-de5da461.js';
import CBox from './CBox.js';
import './index-ff45b78b.js';
import './CPseudoBox.js';
import './closebutton.styles-bab00868.js';
import CCloseButton from './CCloseButton.js';
import './CPortal.js';
import './CNoSsr.js';
import CFragment from './CFragment.js';
import { CPopper, CPopperArrow } from './CPopper.js';

/**
 * Hey! Welcome to @chakra-ui/vue Popover
 *
 * Popover is a non-modal dialog that floats around a trigger. It's used to display contextual information to the user.
 *
 * @see Docs     https://vue.chakra-ui.com/popover
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CPopover/CPopover.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CPopover/accessibility.md
 */
function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CPopover component
 *
 * The wrapper that provides props, state, and context to it's children
 *
 * @extends CFlex
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopover = {
  name: 'CPopover',
  provide: function provide() {
    var this$1 = this;
    return {
      $PopoverContext: function $PopoverContext() {
        return this$1.PopoverContext;
      }
    };
  },
  props: {
    id: String,
    defaultIsOpen: Boolean,
    isOpen: Boolean,
    returnFocusOnClose: {
      type: Boolean,
      default: true
    },
    initialFocusRef: [Object, String, Function],
    trigger: {
      type: String,
      default: 'click'
    },
    closeOnBlur: {
      type: Boolean,
      default: true
    },
    closeOnEscape: {
      type: Boolean,
      default: true
    },
    usePortal: Boolean,
    placement: {
      type: String,
      default: 'auto'
    }
  },
  computed: {
    PopoverContext: function PopoverContext() {
      return {
        set: this.set,
        isOpen: this._isOpen,
        closePopover: this.closePopover,
        openPopover: this.openPopover,
        toggleOpen: this.toggleOpen,
        triggerNode: this.triggerNode,
        contentNode: this.contentNode,
        setTriggerNode: this.setTriggerNode,
        popoverId: this.computedId,
        trigger: this.trigger,
        isHovering: this.isHovering,
        handleBlur: this.handleBlur,
        closeOnEscape: this.closeOnEscape,
        headerId: this.headerId,
        bodyId: this.bodyId,
        usePortal: this.usePortal,
        placement: this.placement
      };
    },
    isControlled: function isControlled() {
      return this.isOpen !== false;
    },
    _isOpen: {
      get: function get() {
        return this.isControlled ? this.isOpen : this.isOpenValue;
      },
      set: function set(value) {
        this.isOpenValue = value;
      }
    },
    _initialFocusRef: function _initialFocusRef() {
      return isFunction(this.initialFocusRef) ? this.getNode(this.initialFocusRef()) : this.getNode(this.initialFocusRef);
    },
    headerId: function headerId() {
      return this.computedId + "-header";
    },
    bodyId: function bodyId() {
      return this.computedId + "-body";
    },
    computedId: function computedId() {
      return this.id || "popover-id-" + useId();
    }
  },
  data: function data() {
    return {
      isOpenValue: this.defaultIsOpen || false,
      triggerNode: undefined,
      contentNode: undefined,
      prevIsOpen: false,
      isHovering: false
    };
  },
  mounted: function mounted() {
    var this$1 = this;
    /**
     * The purpose of this watcher is to keep record of the previous
     * isOpen value.
     */

    this.$watch('_isOpen', function (_newVal, oldVal) {
      this$1.prevIsOpen = oldVal;
    }, {
      immediate: true
    });
    this.$watch(function (vm) {
      return [vm._isOpen, vm._initialFocusRef, vm.trigger, vm.contentNode, vm.triggerNode, vm.prevIsOpen, vm.returnFocusOnClose];
    }, function () {
      if (this$1._isOpen && this$1.trigger === 'click') {
        /**
         * Caveat here:
         * Until Vue 3 is release, using it's $refs as props may not always return a value
         * in the props unless the consumer component updates it's context. This is because
         * Vue asynchronously updtaes the DOM and is also not reactive.
         *
         * Where this doesnt' work, we fallback to using an element selector to query
         * the element from the DOM. And use it as the initial focus ref.
         *
         * Work-around could be to use plain old JS selectors
         */
        setTimeout(function () {
          if (this$1._initialFocusRef) {
            this$1._initialFocusRef.focus();
          } else if (this$1.contentNode) {
            this$1.contentNode.focus();
          }
        });
      }

      if (!this$1._isOpen && this$1.prevIsOpen && this$1.trigger === 'click' && this$1.returnFocusOnClose) {
        if (this$1.triggerNode) {
          this$1.triggerNode.focus();
        }
      }
    });
  },
  methods: {
    /**
     * Closes popover
     */
    closePopover: function closePopover() {
      if (!this.isControlled) {
        this._isOpen = false;
      }

      this.$emit('close');
    },

    /**
     * Opens popover
     */
    openPopover: function openPopover() {
      if (!this.isControlled) {
        this._isOpen = true;
      }

      this.$emit('open');
    },

    /**
     * Toggles disclosure state of popover
     */
    toggleOpen: function toggleOpen() {
      if (!this.isControlled) {
        this._isOpen = !this._isOpen;
      }

      if (this._isOpen !== true) {
        this.$emit('open');
      } else {
        this.$emit('close');
      }
    },

    /**
     * Handles blur event
     * @param {Event} e `blur` event object
     */
    handleBlur: function handleBlur(event) {
      if (this._isOpen && this.closeOnBlur && this.contentNode && this.triggerNode && !this.contentNode.contains(event.relatedTarget) && !this.triggerNode.contains(event.relatedTarget)) {
        this.closePopover();
      }
    },

    /**
     * Returns the HTML element of a Vue component or native element
     * @param {Vue.Component|HTMLElement|String} element HTMLElement or Vue Component
     */
    getNode: function getNode(element) {
      if (_typeof(element) === 'object') {
        var isVue = isVueComponent(element);
        return isVue ? element.$el : element;
      } else if (typeof element === 'string') {
        return getElement(element);
      }

      return null;
    },

    /**
     * Sets the value of any component instance property.
     * This function is to be passed down to context so that consumers
     * can mutate context values with out doing it directly.
     * Serves as a temporary fix until Vue 3 comes out
     * @param {String} prop Component instance property
     * @param {Any} value Property value
     */
    set: function set(prop, value) {
      this[prop] = value;
      return this[prop];
    }
  },
  render: function render(h) {
    return h(CFragment, {
      attrs: {
        'data-chakra-component': 'CPopover'
      }
    }, [this.$scopedSlots.default({
      isOpen: this._isOpen,
      onClose: this.closePopover
    })]);
  }
};
/**
 * CPopoverTrigger component
 *
 * Used to wrap the reference (or trigger) element.
 *
 * @extends this.$slots.default
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverTrigger = {
  name: 'CPopoverTrigger',
  inheritAttrs: false,
  inject: ['$PopoverContext'],
  computed: {
    triggerId: function triggerId() {
      return "popover-trigger-" + useId();
    },
    context: function context() {
      return this.$PopoverContext();
    },
    headerId: function headerId() {
      return this.context.headerId;
    },
    bodyId: function bodyId() {
      return this.context.bodyId;
    },
    eventHandlers: function eventHandlers() {
      var this$1 = this;
      var ref = this.context;
      var trigger = ref.trigger;

      if (trigger === 'click') {
        return {
          click: function click(e) {
            this$1.$emit('click', e);
            this$1.context.toggleOpen();
          }
        };
      }

      if (trigger === 'hover') {
        return {
          focus: function focus(e) {
            this$1.$emit('focus', e);
            this$1.context.openPopover();
          },
          keydown: function keydown(e) {
            this$1.$emit('keydown', e);

            if (e.key === 'Escape') {
              setTimeout(this$1.context.closePopover(), 300);
            }
          },
          blur: function blur(e) {
            this$1.$emit('blur', e);
            this$1.context.closePopover();
          },
          mouseenter: function mouseenter(e) {
            this$1.$emit('mouseenter', e);
            this$1.context.set('isHovering', true);
            setTimeout(this$1.context.openPopover(), 300);
          },
          mouseleave: function mouseleave(e) {
            this$1.$emit('mouseleave', e);
            this$1.context.set('isHovering', false);
            setTimeout(function () {
              if (this$1.context.isHovering === false) {
                this$1.context.closePopover();
              }
            }, 300);
          }
        };
      }
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    var ref = this.context;
    var set = ref.set;
    this.$nextTick(function () {
      var triggerNode = getElement("#" + this$1.triggerId);

      if (!triggerNode) {
        console.warn('[Chakra-ui]: Unable to locate PopoverTrigger node');
      } else {
        set('triggerNode', triggerNode);
      }
    });
  },
  render: function render(h) {
    var children = this.$slots.default.filter(function (e) {
      return e.tag;
    });

    if (!children) {
      return console.error('[Chakra-ui]: Popover Trigger expects at least one child');
    }

    if (children.length && children.length > 1) {
      return console.error('[Chakra-ui]: Popover Trigger can only have a single child element');
    }

    var cloned = cloneVNode(children[0], h);
    var ref = this.context;
    var isOpen = ref.isOpen;
    var popoverId = ref.popoverId;
    var clone = h(cloned.componentOptions.Ctor, Object.assign({}, cloned.data, cloned.componentOptions.listeners || {}, {
      props: Object.assign({}, cloned.data.props || {}, cloned.componentOptions.propsData),
      attrs: Object.assign({}, cloned.data.attrs, this.$attrs, {
        id: this.triggerId,
        'aria-haspopup': 'dialog',
        'aria-expanded': isOpen,
        'aria-controls': popoverId,
        'data-chakra-component': 'CPopoverTrigger'
      }),
      nativeOn: this.eventHandlers
    }), cloned.componentOptions.children);
    return clone;
  }
};
/**
 * CPopoverContent component
 *
 * The popover content element itself.
 *
 * @extends CPopper
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverContent = {
  name: 'CPopoverContent',
  inheritAttrs: false,
  inject: ['$PopoverContext', '$chakraColorMode'],
  props: {
    gutter: {
      type: [Number, String],
      default: 4
    },
    ariaLabel: String
  },
  computed: {
    context: function context() {
      return this.$PopoverContext();
    },
    contentId: function contentId() {
      return "popover-content-" + useId();
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    eventHandlers: function eventHandlers() {
      var this$1 = this;
      var ref = this.context;
      var trigger = ref.trigger;
      var handleBlur = ref.handleBlur;
      var closePopover = ref.closePopover;
      var closeOnEscape = ref.closeOnEscape;
      var eventHandlers = {};

      if (trigger === 'click') {
        eventHandlers = {
          blur: function blur(e) {
            this$1.$emit('blur', e);
            handleBlur(e);
          }
        };
      }

      if (trigger === 'hover') {
        eventHandlers = Object.assign({}, eventHandlers, {
          mouseenter: function mouseenter(e) {
            this$1.$emit('mouseenter', e);
            this$1.context.set('isHovering', true);
            setTimeout(this$1.context.openPopover(), 300);
          },
          mouseleave: function mouseleave(e) {
            this$1.$emit('mouseleave', e);
            this$1.context.set('isHovering', false);
            setTimeout(function () {
              if (this$1.context.isHovering === false) {
                this$1.context.closePopover();
              }
            }, 300);
          }
        });
      }

      eventHandlers = Object.assign({}, eventHandlers, {
        keydown: function keydown(e) {
          this$1.$emit('keydown', e);

          if (e.key === 'Escape' && closeOnEscape) {
            closePopover && closePopover();
          }
        }
      });
      return eventHandlers;
    },
    calculatedAttrs: function calculatedAttrs() {
      var ref = this.context;
      var trigger = ref.trigger;

      if (trigger === 'click') {
        return {
          role: 'dialog',
          'aria-modal': 'false'
        };
      }

      if (trigger === 'hover') {
        return {
          role: 'tooltip'
        };
      }
    }
  },
  mounted: function mounted() {
    var ref = this.context;
    var set = ref.set;
    var popoverId = ref.popoverId;
    this.$nextTick(function () {
      var contentNode = getElement("#" + popoverId);

      if (!contentNode) {
        console.warn('[Chakra-ui]: Unable to locate PopoverContent node');
      } else {
        set('contentNode', contentNode);
      }
    });
  },
  render: function render(h) {
    var ref = this.context;
    var isOpen = ref.isOpen;
    var triggerNode = ref.triggerNode;
    var popoverId = ref.popoverId;
    var usePortal = ref.usePortal;
    var placement = ref.placement;
    var bg = this.colorMode === 'light' ? 'white' : 'gray.700';
    return h(CPopper, {
      props: {
        as: 'section',
        usePortal: usePortal,
        isOpen: isOpen,
        placement: placement,
        anchorEl: triggerNode,
        modifiers: [{
          name: 'offset',
          options: {
            offset: [0, this.gutter]
          }
        }]
      },
      attrs: Object.assign({}, {
        bg: bg,
        width: '100%',
        position: 'relative',
        display: 'flex',
        flexDirection: 'column',
        rounded: 'md',
        shadow: 'sm',
        maxWidth: 'xs',
        _focus: {
          outline: 0,
          shadow: 'outline'
        }
      }, this.$attrs, {
        id: popoverId,
        tabindex: -1,
        'aria-labelledby': this.headerId,
        'aria-describedby': this.bodyId,
        'aria-label': this.ariaLabel,
        'aria-hidden': !isOpen
      }, this.calculatedAttrs, {
        'data-chakra-component': 'CPopoverContent'
      }),
      nativeOn: this.eventHandlers
    }, this.$slots.default);
  }
};
/**
 * CPopoverHeader component
 *
 * The header of the popover.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverHeader = {
  name: 'CPopoverHeader',
  mixins: [createStyledAttrsMixin('CPopoverHeader')],
  inject: ['$PopoverContext'],
  computed: {
    context: function context() {
      return this.$PopoverContext();
    },
    headerId: function headerId() {
      return this.context.headerId;
    },
    componentStyles: function componentStyles() {
      return {
        px: '0.75rem',
        py: '0.5rem',
        borderBottomWidth: '1px'
      };
    }
  },
  render: function render(h) {
    return h('header', {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        id: this.headerId,
        'data-chakra-component': 'CPopoverHeader'
      }),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CPopoverBody component
 *
 * The body of the popover.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverBody = {
  name: 'CPopoverBody',
  mixins: [createStyledAttrsMixin('CPopoverBody')],
  inject: ['$PopoverContext'],
  computed: {
    context: function context() {
      return this.$PopoverContext();
    },
    bodyId: function bodyId() {
      return this.context.bodyId;
    },
    componentStyles: function componentStyles() {
      return {
        flex: 1,
        px: '0.75rem',
        py: '0.5rem'
      };
    }
  },
  render: function render(h) {
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, this.computedAttrs, {
        id: this.bodyId,
        'data-chakra-component': 'CPopoverBody'
      }),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CPopoverArrow component
 *
 * A visual arrow that points to the reference (or trigger).
 *
 * @extends CPopperArrow
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverArrow = {
  name: 'CPopoverArrow',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["data"]);
    var rest = rest$1;
    return h(CPopperArrow, Object.assign({}, rest, {
      attrs: Object.assign({}, data.attrs, {
        'data-chakra-component': 'CPopoverArrow'
      })
    }));
  }
};
/**
 * CPopoverCloseButton component
 *
 * The button to close the popover.
 *
 * @extends CCloseButton
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverCloseButton = {
  name: 'CPopoverCloseButton',
  inheritAttrs: false,
  inject: ['$PopoverContext'],
  computed: {
    context: function context() {
      return this.$PopoverContext();
    }
  },
  render: function render(h) {
    var this$1 = this;
    return h(CCloseButton, {
      props: {
        size: 'sm'
      },
      on: {
        click: function click(e) {
          this$1.$emit('click', e);
          this$1.context.closePopover();
        }
      },
      attrs: Object.assign({}, {
        pos: 'absolute',
        rounded: 'md',
        top: 1,
        right: 2,
        p: 2
      }, this.$attrs, {
        'data-chakra-component': 'CPopoverCloseButton'
      })
    });
  }
};
/**
 * CPopoverFooter component
 *
 * The footer of the popover.
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/popover
 */

var CPopoverFooter = {
  name: 'CPopoverFooter',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var slots = ref.slots;
    var rest$1 = objectWithoutProperties(ref, ["data", "slots"]);
    return h(CBox, {
      props: {
        as: 'footer'
      },
      attrs: Object.assign({}, {
        px: '0.75rem',
        py: '0.5rem',
        borderTopWidth: '1px'
      }, data.attrs, {
        'data-chakra-component': 'CPopoverFooter'
      })
    }, slots().default);
  }
};

export { CPopover, CPopoverArrow, CPopoverBody, CPopoverCloseButton, CPopoverContent, CPopoverFooter, CPopoverHeader, CPopoverTrigger };
