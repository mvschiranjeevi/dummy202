
/*
 * ! @chakra-ui/vue v0.13.1 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

import { H as HTMLElement, J as useId, Z as _typeof, x as getElById, o as canUseDOM, $ as isFunction, r as getFocusables, P as isVueComponent, t as getElement, C as cleanChildren, w as wrapEvent, R as createStyledAttrsMixin } from './index-2216d089.js';
import './chakra-ui-styled-system.esm-a8a2e91f.js';
import './internal-icons-3bdf43cd.js';
import '@emotion/css';
import 'vue';
import './color-mode-observer-de5da461.js';
import './anime.es-fe1e1e1f.js';
import CBox from './CBox.js';
import { C as CIcon } from './index-ff45b78b.js';
import { c as closeButtonProps, s as sizes, b as baseProps } from './closebutton.styles-bab00868.js';
import { CFade } from './CTransition.js';
import CPortal from './CPortal.js';
import './CNoSsr.js';
import { S as StringArray } from './props.types-cbb7b1ff.js';

var defaultParent = typeof document !== 'undefined' ? document.body : null;
var counterMap = new WeakMap();
var uncontrolledNodes = new WeakMap();
var markerMap = {};
var lockCount = 0;
var hideOthers = function (originalTarget, parentNode, markerName) {
    if (parentNode === void 0) { parentNode = defaultParent; }
    if (markerName === void 0) { markerName = "data-aria-hidden"; }
    var targets = Array.isArray(originalTarget) ? originalTarget : [originalTarget];
    if (!markerMap[markerName]) {
        markerMap[markerName] = new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var deep = function (parent) {
        if (!parent || targets.indexOf(parent) >= 0) {
            return;
        }
        Array.prototype.forEach.call(parent.children, function (node) {
            if (targets.some(function (target) { return node.contains(target); })) {
                deep(node);
            }
            else {
                var attr = node.getAttribute('aria-hidden');
                var alreadyHidden = attr !== null && attr !== 'false';
                var counterValue = (counterMap.get(node) || 0) + 1;
                var markerValue = (markerCounter.get(node) || 0) + 1;
                counterMap.set(node, counterValue);
                markerCounter.set(node, markerValue);
                hiddenNodes.push(node);
                if (counterValue === 1 && alreadyHidden) {
                    uncontrolledNodes.set(node, true);
                }
                if (markerValue === 1) {
                    node.setAttribute(markerName, 'true');
                }
                if (!alreadyHidden) {
                    node.setAttribute('aria-hidden', 'true');
                }
            }
        });
    };
    deep(parentNode);
    lockCount++;
    return function () {
        hiddenNodes.forEach(function (node) {
            var counterValue = counterMap.get(node) - 1;
            var markerValue = markerCounter.get(node) - 1;
            counterMap.set(node, counterValue);
            markerCounter.set(node, markerValue);
            if (!counterValue) {
                if (!uncontrolledNodes.has(node)) {
                    node.removeAttribute('aria-hidden');
                }
                uncontrolledNodes.delete(node);
            }
            if (!markerValue) {
                node.removeAttribute(markerName);
            }
        });
        lockCount--;
        if (!lockCount) {
            counterMap = new WeakMap();
            counterMap = new WeakMap();
            uncontrolledNodes = new WeakMap();
            markerMap = {};
        }
    };
};

var candidateSelectors = [
  'input',
  'select',
  'textarea',
  'a[href]',
  'button',
  '[tabindex]',
  'audio[controls]',
  'video[controls]',
  '[contenteditable]:not([contenteditable="false"])' ];
var candidateSelector = candidateSelectors.join(',');

var matches = typeof Element === 'undefined'
  ? function () {}
  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

function tabbable(el, options) {
  options = options || {};

  var regularTabbables = [];
  var orderedTabbables = [];

  var candidates = el.querySelectorAll(candidateSelector);

  if (options.includeContainer) {
    if (matches.call(el, candidateSelector)) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el);
    }
  }

  var i, candidate, candidateTabindex;
  for (i = 0; i < candidates.length; i++) {
    candidate = candidates[i];

    if (!isNodeMatchingSelectorTabbable(candidate)) { continue; }

    candidateTabindex = getTabindex(candidate);
    if (candidateTabindex === 0) {
      regularTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        node: candidate,
      });
    }
  }

  var tabbableNodes = orderedTabbables
    .sort(sortOrderedTabbables)
    .map(function(a) { return a.node })
    .concat(regularTabbables);

  return tabbableNodes;
}

tabbable.isTabbable = isTabbable;
tabbable.isFocusable = isFocusable;

function isNodeMatchingSelectorTabbable(node) {
  if (
    !isNodeMatchingSelectorFocusable(node)
    || isNonTabbableRadio(node)
    || getTabindex(node) < 0
  ) {
    return false;
  }
  return true;
}

function isTabbable(node) {
  if (!node) { throw new Error('No node provided'); }
  if (matches.call(node, candidateSelector) === false) { return false; }
  return isNodeMatchingSelectorTabbable(node);
}

function isNodeMatchingSelectorFocusable(node) {
  if (
    node.disabled
    || isHiddenInput(node)
    || isHidden(node)
  ) {
    return false;
  }
  return true;
}

var focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');
function isFocusable(node) {
  if (!node) { throw new Error('No node provided'); }
  if (matches.call(node, focusableCandidateSelector) === false) { return false; }
  return isNodeMatchingSelectorFocusable(node);
}

function getTabindex(node) {
  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);
  if (!isNaN(tabindexAttr)) { return tabindexAttr; }
  // Browsers do not return `tabIndex` correctly for contentEditable nodes;
  // so if they don't have a tabindex attribute specifically set, assume it's 0.
  if (isContentEditable(node)) { return 0; }
  return node.tabIndex;
}

function sortOrderedTabbables(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
}

function isContentEditable(node) {
  return node.contentEditable === 'true';
}

function isInput(node) {
  return node.tagName === 'INPUT';
}

function isHiddenInput(node) {
  return isInput(node) && node.type === 'hidden';
}

function isRadio(node) {
  return isInput(node) && node.type === 'radio';
}

function isNonTabbableRadio(node) {
  return isRadio(node) && !isTabbableRadio(node);
}

function getCheckedRadio(nodes) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked) {
      return nodes[i];
    }
  }
}

function isTabbableRadio(node) {
  if (!node.name) { return true; }
  // This won't account for the edge case where you have radio groups with the same
  // in separate forms on the same page.
  var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
  var checked = getCheckedRadio(radioSet);
  return !checked || checked === node;
}

function isHidden(node) {
  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,
  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.
  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';
}

var tabbable_1 = tabbable;

var immutable = extend;

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var arguments$1 = arguments;

    var target = {};

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments$1[i];

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target
}

var activeFocusDelay;

var activeFocusTraps = (function() {
  var trapQueue = [];
  return {
    activateTrap: function(trap) {
      if (trapQueue.length > 0) {
        var activeTrap = trapQueue[trapQueue.length - 1];
        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }

      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex === -1) {
        trapQueue.push(trap);
      } else {
        // move this existing trap to the front of the queue
        trapQueue.splice(trapIndex, 1);
        trapQueue.push(trap);
      }
    },

    deactivateTrap: function(trap) {
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex !== -1) {
        trapQueue.splice(trapIndex, 1);
      }

      if (trapQueue.length > 0) {
        trapQueue[trapQueue.length - 1].unpause();
      }
    }
  };
})();

function focusTrap(element, userOptions) {
  var doc = document;
  var container =
    typeof element === 'string' ? doc.querySelector(element) : element;

  var config = immutable(
    {
      returnFocusOnDeactivate: true,
      escapeDeactivates: true
    },
    userOptions
  );

  var state = {
    firstTabbableNode: null,
    lastTabbableNode: null,
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false
  };

  var trap = {
    activate: activate,
    deactivate: deactivate,
    pause: pause,
    unpause: unpause
  };

  return trap;

  function activate(activateOptions) {
    if (state.active) { return; }

    updateTabbableNodes();

    state.active = true;
    state.paused = false;
    state.nodeFocusedBeforeActivation = doc.activeElement;

    var onActivate =
      activateOptions && activateOptions.onActivate
        ? activateOptions.onActivate
        : config.onActivate;
    if (onActivate) {
      onActivate();
    }

    addListeners();
    return trap;
  }

  function deactivate(deactivateOptions) {
    if (!state.active) { return; }

    clearTimeout(activeFocusDelay);

    removeListeners();
    state.active = false;
    state.paused = false;

    activeFocusTraps.deactivateTrap(trap);

    var onDeactivate =
      deactivateOptions && deactivateOptions.onDeactivate !== undefined
        ? deactivateOptions.onDeactivate
        : config.onDeactivate;
    if (onDeactivate) {
      onDeactivate();
    }

    var returnFocus =
      deactivateOptions && deactivateOptions.returnFocus !== undefined
        ? deactivateOptions.returnFocus
        : config.returnFocusOnDeactivate;
    if (returnFocus) {
      delay(function() {
        tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
      });
    }

    return trap;
  }

  function pause() {
    if (state.paused || !state.active) { return; }
    state.paused = true;
    removeListeners();
  }

  function unpause() {
    if (!state.paused || !state.active) { return; }
    state.paused = false;
    updateTabbableNodes();
    addListeners();
  }

  function addListeners() {
    if (!state.active) { return; }

    // There can be only one listening focus trap at a time
    activeFocusTraps.activateTrap(trap);

    // Delay ensures that the focused element doesn't capture the event
    // that caused the focus trap activation.
    activeFocusDelay = delay(function() {
      tryFocus(getInitialFocusNode());
    });

    doc.addEventListener('focusin', checkFocusIn, true);
    doc.addEventListener('mousedown', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('touchstart', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('click', checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener('keydown', checkKey, {
      capture: true,
      passive: false
    });

    return trap;
  }

  function removeListeners() {
    if (!state.active) { return; }

    doc.removeEventListener('focusin', checkFocusIn, true);
    doc.removeEventListener('mousedown', checkPointerDown, true);
    doc.removeEventListener('touchstart', checkPointerDown, true);
    doc.removeEventListener('click', checkClick, true);
    doc.removeEventListener('keydown', checkKey, true);

    return trap;
  }

  function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    var node = optionValue;
    if (!optionValue) {
      return null;
    }
    if (typeof optionValue === 'string') {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error('`' + optionName + '` refers to no known node');
      }
    }
    if (typeof optionValue === 'function') {
      node = optionValue();
      if (!node) {
        throw new Error('`' + optionName + '` did not return a node');
      }
    }
    return node;
  }

  function getInitialFocusNode() {
    var node;
    if (getNodeForOption('initialFocus') !== null) {
      node = getNodeForOption('initialFocus');
    } else if (container.contains(doc.activeElement)) {
      node = doc.activeElement;
    } else {
      node = state.firstTabbableNode || getNodeForOption('fallbackFocus');
    }

    if (!node) {
      throw new Error(
        'Your focus-trap needs to have at least one focusable element'
      );
    }

    return node;
  }

  function getReturnFocusNode(previousActiveElement) {
    var node = getNodeForOption('setReturnFocus');
    return node ? node : previousActiveElement;
  }

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event.
  function checkPointerDown(e) {
    if (container.contains(e.target)) { return; }
    if (config.clickOutsideDeactivates) {
      deactivate({
        returnFocus: !tabbable_1.isFocusable(e.target)
      });
      return;
    }
    // This is needed for mobile devices.
    // (If we'll only let `click` events through,
    // then on mobile they will be blocked anyways if `touchstart` is blocked.)
    if (config.allowOutsideClick && config.allowOutsideClick(e)) {
      return;
    }
    e.preventDefault();
  }

  // In case focus escapes the trap for some strange reason, pull it back in.
  function checkFocusIn(e) {
    // In Firefox when you Tab out of an iframe the Document is briefly focused.
    if (container.contains(e.target) || e.target instanceof Document) {
      return;
    }
    e.stopImmediatePropagation();
    tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
  }

  function checkKey(e) {
    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
      e.preventDefault();
      deactivate();
      return;
    }
    if (isTabEvent(e)) {
      checkTab(e);
      return;
    }
  }

  // Hijack Tab events on the first and last focusable nodes of the trap,
  // in order to prevent focus from escaping. If it escapes for even a
  // moment it can end up scrolling the page and causing confusion so we
  // kind of need to capture the action at the keydown phase.
  function checkTab(e) {
    updateTabbableNodes();
    if (e.shiftKey && e.target === state.firstTabbableNode) {
      e.preventDefault();
      tryFocus(state.lastTabbableNode);
      return;
    }
    if (!e.shiftKey && e.target === state.lastTabbableNode) {
      e.preventDefault();
      tryFocus(state.firstTabbableNode);
      return;
    }
  }

  function checkClick(e) {
    if (config.clickOutsideDeactivates) { return; }
    if (container.contains(e.target)) { return; }
    if (config.allowOutsideClick && config.allowOutsideClick(e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  }

  function updateTabbableNodes() {
    var tabbableNodes = tabbable_1(container);
    state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();
    state.lastTabbableNode =
      tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();
  }

  function tryFocus(node) {
    if (node === doc.activeElement) { return; }
    if (!node || !node.focus) {
      tryFocus(getInitialFocusNode());
      return;
    }
    node.focus();
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  }
}

function isSelectableInput(node) {
  return (
    node.tagName &&
    node.tagName.toLowerCase() === 'input' &&
    typeof node.select === 'function'
  );
}

function isEscapeEvent(e) {
  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
}

function isTabEvent(e) {
  return e.key === 'Tab' || e.keyCode === 9;
}

function delay(fn) {
  return setTimeout(fn, 0);
}

var focusTrap_1 = focusTrap;

/*!
  * focus-trap-vue v0.0.4
  * (c) 2019 Eduardo San Martin Morote
  * @license MIT
  */

// import Component from 'vue-class-component'
// @ts-ignore
var FocusTrap = {
    // @ts-ignore
    props: {
        active: {
            // TODO: could be options for activate
            type: Boolean,
            default: true,
        },
        escapeDeactivates: {
            type: Boolean,
            default: true,
        },
        returnFocusOnDeactivate: {
            type: Boolean,
            default: true,
        },
        allowOutsideClick: {
            type: Boolean,
            default: true,
        },
        initialFocus: [String, Function],
        fallbackFocus: [String, Function],
    },
    model: {
        event: 'update:active',
        prop: 'active',
    },
    mounted: function mounted() {
        var this$1 = this;

        this.$watch('active', function (active) {
            if (active) {
                // has no effect if already activated
                this$1.trap = focusTrap_1(
                // @ts-ignore
                this$1.$el, {
                    escapeDeactivates: this$1.escapeDeactivates,
                    allowOutsideClick: function () { return this$1.allowOutsideClick; },
                    returnFocusOnDeactivate: this$1.returnFocusOnDeactivate,
                    onActivate: function () {
                        this$1.$emit('update:active', true);
                        this$1.$emit('activate');
                    },
                    onDeactivate: function () {
                        this$1.$emit('update:active', false);
                        this$1.$emit('deactivate');
                    },
                    initialFocus: this$1.initialFocus || (function () { return this$1.$el; }),
                    fallbackFocus: this$1.fallbackFocus,
                });
                this$1.trap.activate();
            }
            else {
                this$1.trap && this$1.trap.deactivate();
            }
        }, { immediate: true });
    },
    beforeDestroy: function beforeDestroy() {
        this.trap && this.trap.deactivate();
        // @ts-ignore
        this.trap = null;
    },
    methods: {
        activate: function activate() {
            // @ts-ignore
            this.trap.activate();
        },
        deactivate: function deactivate() {
            // @ts-ignore
            this.trap.deactivate();
        },
    },
    render: function render() {
        var content = this.$slots.default;
        if (!content || !content.length || content.length > 1)
            { throw new Error('FocusTrap requires exactly one child'); }
        return content[0];
    },
};

var props = {
  isOpen: Boolean,
  initialFocusRef: [HTMLElement, Object, String, Function],
  finalFocusRef: [HTMLElement, Object, String, Function],
  contentRef: [HTMLElement, Object, String],
  blockScrollOnMount: {
    type: Boolean,
    default: true
  },
  closeOnEsc: {
    type: Boolean,
    default: true
  },
  closeOnOverlayClick: {
    type: Boolean,
    default: true
  },
  useInert: {
    type: Boolean,
    default: true
  },
  scrollBehavior: {
    type: StringArray,
    default: 'outside'
  },
  isCentered: Boolean,
  addAriaLabels: {
    type: [Boolean, Object],
    default: true
  },
  preserveScrollBarGap: Boolean,
  formatIds: {
    type: Function,
    default: function _default(id) {
      return {
        content: "modal-" + id,
        header: "modal-" + id + "-header",
        body: "modal-" + id + "-body"
      };
    }
  },
  container: HTMLElement,
  returnFocusOnClose: {
    type: Boolean,
    default: true
  },
  id: String,
  size: {
    type: String,
    default: 'md'
  },
  onClose: {
    type: Function,
    default: function _default() {
      return null;
    }
  }
};

/**
 * Hey! Welcome to @chakra-ui/vue Menu
 *
 * The `CModal` is a dialog window overlaid on either the primary window or another dialog
 *  window. Contents behind a modal dialog are **inert** meaning that users cannot
 * interact with content behind the dialog.
 *
 * @see Docs     https://vue.chakra-ui.com/modal
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CModal/CModal.js
 * @see A11y     https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CModal/accessibility.md
 */
function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];
  }

  return target;
}
/**
 * CModal component
 *
 * The wrapper for `CModal` components. It provides context and state for the modal.
 *
 * @extends CPortal
 * @see Docs https://vue.chakra-ui.com/modal
 */

var CModal = {
  name: 'CModal',
  props: props,
  data: function data() {
    return {
      addAriaLabelledby: false,
      addAriaDescribedby: false,
      modalNode: undefined,
      contentNode: undefined
    };
  },
  provide: function provide() {
    var this$1 = this;
    return {
      $ModalContext: function $ModalContext() {
        return this$1.ModalContext;
      }
    };
  },
  computed: {
    _id: function _id() {
      return this.id || useId(4);
    },
    contentId: function contentId() {
      return this.formatIds(this._id).content;
    },
    headerId: function headerId() {
      return this.formatIds(this._id).header;
    },
    bodyId: function bodyId() {
      return this.formatIds(this._id).body;
    },
    modalId: function modalId() {
      return "modal-" + this._id;
    },
    portalTarget: function portalTarget() {
      return "#modal-portal-" + this._id;
    },
    ModalContext: function ModalContext() {
      return {
        isOpen: this.isOpen,
        initialFocusRef: this.initialFocusRef,
        onClose: this.onClose,
        blockScrollOnMount: this.blockScrollOnMount,
        closeOnEsc: this.closeOnEsc,
        closeOnOverlayClick: this.closeOnOverlayClick,
        returnFocusOnClose: this.returnFocusOnClose,
        contentNode: this.contentNode,
        scrollBehavior: this.scrollBehavior,
        isCentered: this.isCentered,
        size: this.size,
        headerId: this.headerId,
        bodyId: this.bodyId,
        contentId: this.contentId,
        addAriaLabelledby: this.addAriaLabelledby,
        addAriaDescribedby: this.addAriaDescribedby
      };
    }
  },
  mounted: function mounted() {
    var this$1 = this;

    if (_typeof(this.addAriaLabels) === 'object') {
      this.addAriaLabelledby = this.addAriaLabels.header;
      this.addAriaDescribedby = this.addAriaLabels.body;
    }

    if (typeof this.addAriaLabels === 'boolean') {
      this.addAriaLabelledby = this.addAriaLabels;
      this.addAriaDescribedby = this.addAriaLabels;
    }

    this.$nextTick(function () {
      this$1.modalNode = getElById(this$1.modalId);
    });
    /**
     * Escape key press event handler for modal
     * @param {Event} event Keyboard Event
     */

    var handler = function handler(event) {
      if (event.key === 'Escape' && this$1.closeOnEsc) {
        this$1.onClose(event, 'pressedEscape');
      }
    };

    this.$watch(function (vm) {
      return [vm.isOpen, vm.blockScrollOnMount];
    }, function () {
      if (this$1.isOpen && !this$1.closeOnOverlayClick) {
        canUseDOM && document.addEventListener('keydown', handler);
      } else {
        document.addEventListener('keydown', handler);
      }
    });
    this.$watch('isOpen', function () {
      if (!this$1.isOpen) {
        document.removeEventListener('keydown', handler);
      }
    });
    var undoAriaHidden = null;
    this.$watch(function (vm) {
      return [vm.isOpen, vm.useInert];
    }, function () {
      var mountNode = this$1.mountNode;

      if (this$1.isOpen && canUseDOM) {
        if (this$1.useInert) {
          undoAriaHidden = hideOthers(mountNode);
        }

        this$1.contentNode = getElById(this$1.contentId);
      } else if (this$1.useInert && undoAriaHidden != null) {
        undoAriaHidden();
      }
    });
  },
  methods: {
    /**
     * Handles focus trap activation
     */
    activateFocusLock: function activateFocusLock() {
      var this$1 = this;
      setTimeout(function () {
        if (this$1.initialFocusRef) {
          var initialFocusRef = isFunction(this$1.initialFocusRef) ? this$1.getNode(this$1.initialFocusRef()) : this$1.getNode(this$1.initialFocusRef);

          if (initialFocusRef) {
            initialFocusRef.focus();
          }
        } else {
          var contentNode = getElById(this$1.contentId);

          if (contentNode) {
            var focusables = getFocusables(contentNode);

            if (focusables.length === 0) {
              contentNode.focus();
            } else {
              var el = focusables[0];
              el && el.focus();
            }
          }
        }
      });
    },

    /**
     * Handles focus trap deactivation
     */
    deactivateFocusLock: function deactivateFocusLock() {
      var this$1 = this;
      setTimeout(function () {
        if (this$1.finalFocusRef) {
          var finalFocusRef = isFunction(this$1.finalFocusRef) ? this$1.getNode(this$1.finalFocusRef()) : this$1.getNode(this$1.finalFocusRef);

          if (finalFocusRef) {
            canUseDOM && finalFocusRef.focus();
          } else {
            console.warn("[ChakraUI Modal]: Unable to locate final focus node \"" + this$1.finalFocusRef + "\".");
          }
        }
      });
    },

    /**
     * Gets the HTML element for a component or selector
     * @param {Object|String} element Element or selector
     */
    getNode: function getNode(element) {
      if (_typeof(element) === 'object') {
        var isVue = isVueComponent(element);
        return isVue ? element.$el : element;
      } else if (typeof element === 'string') {
        return getElement(element);
      }

      return null;
    }
  },
  render: function render(h) {
    var children = cleanChildren(this.$slots.default);
    return h(CPortal, {
      props: {
        append: true,
        target: this.portalTarget,
        disabled: false,
        slim: true,
        unmountOnDestroy: true,
        targetSlim: true
      },
      attrs: {
        'data-chakra-component': 'CModal'
      }
    }, [h(FocusTrap, {
      props: {
        returnFocusOnDeactivate: this.returnFocusOnClose && !this.finalFocusRef,
        active: this.isOpen
      },
      on: {
        activate: this.activateFocusLock,
        deactivate: this.deactivateFocusLock
      }
    }, [h('div', {
      style: {
        position: 'relative'
      },
      directives: [{
        name: 'scroll-lock',
        value: this.isOpen && this.blockScrollOnMount
      }]
    }, [h(CFade, {
      props: {
        enterEasing: 'easeInCubic',
        leaveEasing: 'easeOutCubic'
      }
    }, this.isOpen && [h('div', {
      style: {
        position: 'fixed',
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    }, children)])])])]);
  }
};
/**
 * CModalOverlay component
 *
 * The background overlay for the `CModal` component
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/modal
 */

var CModalOverlay = {
  name: 'CModalOverlay',
  functional: true,
  render: function render(h, ref) {
    var data = ref.data;
    var rest$1 = objectWithoutProperties(ref, ["data"]);
    var rest = rest$1;
    return h(CBox, Object.assign({}, rest, {
      attrs: Object.assign({}, {
        pos: 'fixed',
        bg: 'rgba( 0, 0, 0, 0.4)',
        left: '0',
        top: '0',
        w: '100vw',
        h: '100vh',
        zIndex: 'overlay'
      }, data.attrs, {
        'data-chakra-component': 'CModalOverlay'
      })
    }));
  }
};
/**
 * CModalContent component
 *
 * The container for the CModal content
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/modal
 */

var CModalContent = {
  name: 'CModalContent',
  inheritAttrs: false,
  inject: ['$ModalContext', '$chakraColorMode'],
  props: {
    noStyles: Boolean,
    zIndex: {
      type: String,
      default: 'modal'
    }
  },
  data: function data() {
    return {
      colorModeStyles: {
        light: {
          bg: 'white',
          shadow: '0 7px 14px 0 rgba(0, 0, 0, 0.1), 0 3px 6px 0 rgba(0, 0, 0, .07)'
        },
        dark: {
          bg: 'gray.700',
          shadow: 'rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px',
          color: 'whiteAlpha.900'
        }
      },
      wrapperStyle: {},
      contentStyle: {}
    };
  },
  computed: {
    context: function context() {
      return this.$ModalContext();
    },
    colorMode: function colorMode() {
      return this.$chakraColorMode();
    },
    boxStyleProps: function boxStyleProps() {
      return this.colorModeStyles[this.colorMode];
    },
    componentStyles: function componentStyles() {
      return Object.assign({}, this.wrapperStyle, {
        pos: 'fixed',
        left: '0',
        top: '0',
        w: '100%',
        h: '100%',
        zIndex: this.zIndex || 'modal'
      });
    }
  },
  created: function created() {
    var ref = this.context;
    var isCentered = ref.isCentered;
    var scrollBehavior = ref.scrollBehavior;
    var wrapperStyle = {};
    var contentStyle = {};

    if (isCentered) {
      wrapperStyle = {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      };
    } else {
      contentStyle = {
        top: '3.75rem',
        mx: 'auto'
      };
    }

    if (scrollBehavior === 'inside') {
      wrapperStyle = Object.assign({}, wrapperStyle, {
        maxHeight: 'calc(100vh - 7.5rem)',
        overflow: 'hidden',
        top: '3.75rem'
      });
      contentStyle = Object.assign({}, contentStyle, {
        height: '100%',
        top: 0
      });
    }

    if (scrollBehavior === 'outside') {
      wrapperStyle = Object.assign({}, wrapperStyle, {
        overflowY: 'auto',
        overflowX: 'hidden'
      });
      contentStyle = Object.assign({}, contentStyle, {
        my: '3.75rem',
        top: 0
      });
    }

    if (this.noStyles) {
      wrapperStyle = {};
      contentStyle = {};
    }

    this.wrapperStyle = wrapperStyle;
    this.contentStyle = contentStyle;
  },
  render: function render(h) {
    var this$1 = this;
    var ref = this.context;
    var onClose = ref.onClose;
    var bodyId = ref.bodyId;
    var headerId = ref.headerId;
    var contentId = ref.contentId;
    var size = ref.size;
    var closeOnEsc = ref.closeOnEsc;
    var addAriaLabelledby = ref.addAriaLabelledby;
    var addAriaDescribedby = ref.addAriaDescribedby;
    var closeOnOverlayClick = ref.closeOnOverlayClick;
    return h(CBox, {
      attrs: Object.assign({}, this.wrapperStyle, {
        pos: 'fixed',
        left: '0',
        top: '0',
        w: '100%',
        h: '100%',
        zIndex: this.zIndex || 'modal'
      }),
      on: {
        click: function click(event) {
          event.stopPropagation();

          if (closeOnOverlayClick) {
            onClose && onClose(event, 'clickedOverlay');
            this$1.$emit('clickedOverlay', event);
          }
        },
        keydown: function keydown(event) {
          if (event.key === 'Escape') {
            event.stopPropagation();

            if (closeOnEsc) {
              onClose(event, 'pressedEscape');
            }
          }
        }
      }
    }, [h(CBox, {
      props: {
        as: 'section'
      },
      attrs: Object.assign({}, {
        role: 'dialog',
        'aria-modal': 'true',
        tabindex: -1,
        id: contentId
      }, addAriaDescribedby && {
        'aria-describedby': bodyId
      }, addAriaLabelledby && {
        'aria-labelledby': headerId
      }, {
        outline: 0,
        maxWidth: size,
        w: '100%',
        pos: 'relative',
        d: 'flex',
        flexDir: 'column',
        zIndex: this.zIndex,
        fontFamily: 'body'
      }, this.boxStyleProps, this.contentStyle, {
        'data-chakra-component': 'CModalContent'
      }, this.$attrs),
      nativeOn: {
        click: wrapEvent(function (e) {
          return this$1.$emit('click', e);
        }, function (event) {
          return event.stopPropagation();
        })
      }
    }, this.$slots.default)]);
  }
};
/**
 * CModalHeader component
 *
 * The header that labels the modal dialog
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/modal
 */

var CModalHeader = {
  name: 'CModalHeader',
  mixins: [createStyledAttrsMixin('CModalHeader')],
  inject: ['$ModalContext'],
  computed: {
    context: function context() {
      return this.$ModalContext();
    },
    componentStyles: function componentStyles() {
      return {
        px: 6,
        py: 4,
        position: 'relative',
        fontSize: 'xl',
        fontWeight: 'semibold'
      };
    }
  },
  render: function render(h) {
    var ref = this.context;
    var headerId = ref.headerId;
    return h('header', {
      class: [this.className],
      attrs: Object.assign({}, {
        id: headerId
      }, this.computedAttrs),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CModalFooter component
 *
 * The footer that houses the modal actions
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/modal
 */

var CModalFooter = {
  name: 'CModalFooter',
  functional: true,
  render: function render(h, ref) {
    var slots = ref.slots;
    var data = ref.data;
    return h(CBox, Object.assign({}, data, {
      attrs: Object.assign({}, {
        as: 'footer',
        display: 'flex',
        px: 6,
        py: 4,
        justifyContent: 'flex-end',
        'data-chakra-component': 'CModalFooter'
      }, data.attrs)
    }), slots().default);
  }
};
/**
 * CModalBody component
 *
 * The wrapper that houses the modal's main content
 *
 * @extends CBox
 * @see Docs https://vue.chakra-ui.com/modal
 */

var CModalBody = {
  name: 'CModalBody',
  mixins: [createStyledAttrsMixin('CModalBody')],
  inject: ['$ModalContext'],
  computed: {
    context: function context() {
      return this.$ModalContext();
    },
    componentStyles: function componentStyles() {
      var ref = this.context;
      var scrollBehavior = ref.scrollBehavior;
      var style = {};

      if (scrollBehavior === 'inside') {
        style = {
          overflowY: 'auto'
        };
      }

      return Object.assign({}, {
        px: 6,
        py: 2,
        flex: 1
      }, style);
    }
  },
  render: function render(h) {
    var ref = this.context;
    var bodyId = ref.bodyId;
    return h(this.as, {
      class: [this.className],
      attrs: Object.assign({}, {
        id: bodyId,
        'data-chakra-component': 'CModalBody'
      }, this.computedAttrs),
      on: this.computedListeners
    }, this.$slots.default);
  }
};
/**
 * CCloseButton component
 *
 * The button that closes the modal.
 *
 * @extends CCloseButton
 * @see Docs https://vue.chakra-ui.com/modal
 */

var CModalCloseButton = {
  name: 'CModalCloseButton',
  mixins: [createStyledAttrsMixin('CModalCloseButton')],
  inject: ['$ModalContext'],
  props: closeButtonProps,
  computed: {
    context: function context() {
      return this.$ModalContext();
    },
    componentStyles: function componentStyles() {
      var colorMode = this.colorMode; // Pseudo styles

      var hoverColor = {
        light: 'blackAlpha.100',
        dark: 'whiteAlpha.100'
      };
      var activeColor = {
        light: 'blackAlpha.200',
        dark: 'whiteAlpha.200'
      }; // Size styles

      var buttonSize = sizes[this.size] && sizes[this.size].button;
      return Object.assign({}, {
        outline: 'none',
        h: buttonSize,
        w: buttonSize,
        disabled: this.isDisabled,
        cursor: 'pointer',
        _hover: {
          bg: hoverColor[colorMode]
        },
        _active: {
          bg: activeColor[colorMode]
        },
        position: 'absolute',
        top: '8px',
        right: '12px'
      }, baseProps);
    }
  },
  render: function render(h) {
    var this$1 = this;
    var ref = this.context;
    var onClose = ref.onClose;
    var iconSize = sizes[this.size] && sizes[this.size].icon;
    return h('button', {
      class: [this.className],
      attrs: Object.assign({}, {
        'data-chakra-component': 'CModalCloseButton'
      }, this.computedAttrs, {
        'aria-label': this.ariaLabel,
        'aria-disabled': this.isDisabled
      }),
      on: Object.assign({}, this.computedListeners, {
        click: function click(e) {
          wrapEvent(onClose, function (event) {
            return this$1.$emit('click', event);
          })(e);
        }
      }, this.computedListeners)
    }, [h(CIcon, {
      props: {
        color: props.color,
        name: 'close',
        size: iconSize
      },
      attrs: {
        focusable: false,
        'aria-hidden': true
      }
    })]);
  }
};

export { CModal, CModalBody, CModalCloseButton, CModalContent, CModalFooter, CModalHeader, CModalOverlay };
