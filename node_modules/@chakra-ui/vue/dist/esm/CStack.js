
/*
 * ! @chakra-ui/vue v0.13.1 by Jonathan Bakebwa @codebender828
 * MIT License
 * https://github.com/chakra-ui/chakra-ui-vue
 */

import { R as createStyledAttrsMixin, y as cloneVNode } from './index-2216d089.js';
import './chakra-ui-styled-system.esm-a8a2e91f.js';
import '@emotion/css';
import 'vue';
import './color-mode-observer-de5da461.js';
import CBox from './CBox.js';
import { S as StringArray, a as SNA } from './props.types-cbb7b1ff.js';
import { C as CFlex } from './index-dbd7e06a.js';

/**
 * Hey! Welcome to @chakra-ui/vue Stack
 *
 * Stack is a layout utility component that makes
 * it easy to stack elements together and apply a space between them.
 *
 * @see Docs     https://vue.chakra-ui.com/stack
 * @see Source   https://github.com/chakra-ui/chakra-ui-vue/blob/master/packages/chakra-ui-core/src/CStack/CStack.js
 */
/**
 * CStack component
 *
 * Flex container to stck it's children
 *
 * @extends CFlex
 * @see Docs https://vue.chakra-ui.com/stack
 */

var CStack = {
  name: 'CStack',
  mixins: [createStyledAttrsMixin('CStack')],
  props: {
    direction: [String, Array],
    isInline: {
      type: Boolean,
      default: false
    },
    isReversed: {
      type: Boolean,
      default: false
    },
    align: StringArray,
    justify: StringArray,
    spacing: {
      type: SNA,
      default: 2
    },
    shouldWrapChildren: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    _isInline: function _isInline() {
      return this.isInline || this.direction && this.direction.startsWith('row');
    },
    _isReversed: function _isReversed() {
      return this.isReversed || this.direction && this.direction.endsWith('reverse');
    },
    _direction: function _direction() {
      var _direction;

      if (this._isInline) {
        _direction = 'row';
      }

      if (this._isReversed) {
        _direction = this.isInline ? 'row-reverse' : 'column-reverse';
      }

      if (this.direction) {
        _direction = this.direction;
      }

      if (!this._isInline && !this._isReversed && !this.direction) {
        _direction = 'column';
      }

      return _direction;
    }
  },
  render: function render(h) {
    var this$1 = this;
    var defaultSlot = this.$slots.default || [];
    var children = defaultSlot.filter(function (e) {
      return e.tag;
    });
    var stackables = children.map(function (node, index) {
      var obj, obj$1;
      var isLastChild = children.length === index + 1;
      var spacingProps = this$1._isInline ? (obj = {}, obj[this$1._isReversed ? 'ml' : 'mr'] = isLastChild ? null : this$1.spacing, obj) : (obj$1 = {}, obj$1[this$1._isReversed ? 'mt' : 'mb'] = isLastChild ? null : this$1.spacing, obj$1);
      var clone = cloneVNode(node, h);

      if (!clone.componentOptions) {
        clone = h(CBox, [clone]);
      }

      var ref = clone.componentOptions;
      var propsData = ref.propsData;
      var ref$1 = clone.data;
      var attrs = ref$1.attrs; // If children nodes should wrap,
      // we wrap them inside block with
      // display set to inline block.

      if (this$1.shouldWrapChildren) {
        return h(CBox, {
          props: {
            as: this$1.as,
            to: this$1.to
          },
          attrs: Object.assign({}, {
            d: 'inline-block'
          }, spacingProps)
        }, [clone]);
      } // Otherwise we simply set spacing props
      // to current node.


      clone.componentOptions.propsData = Object.assign({}, propsData);
      clone.data.attrs = Object.assign({}, attrs, spacingProps);
      return clone;
    });
    return h(CFlex, {
      class: this.className,
      props: {
        as: this.as,
        align: this.align,
        justify: this.justify,
        direction: this._direction
      },
      attrs: this.computedAttrs,
      on: this.computedListeners
    }, stackables);
  }
};

export default CStack;
